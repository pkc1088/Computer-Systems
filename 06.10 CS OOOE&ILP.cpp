/*
instruction level parrallelism 
https://talkingaboutme.tistory.com/entry/Computer-Architecture-What-is-ILP

비순차적 명령어 처리(Out-of-order execution, 줄여서 OoOE) 또는 비순차적 실행은 고성능 
마이크로프로세서가 특정한 종류의 지연으로 인해 낭비될 수 있는 명령 사이클을 이용하는 
패러다임이다. 명령 실행 효율을 높이기 위해 순서에 따라 처리하지 않는 기법이며 수많은 
프로세서가 채용하고 있다.


기본 개념
프로그래머는 프로그램을 짤 때 자신이 만든 코드가 차례대로 (분기문이 없다면 위에서 아래로) 
실행될 것으로 믿는다. 순차 프로세서는 이 순서를 그대로 지켜가며 실행한다. 그러나 어떤 
메모리 로드 명령어가 캐시 미스를 겪고 있다고 가정해 보자. 만약 이를 뒤따르는 명령어 
가운데 이 로드 명령어와 상관이 없는 것이라면 분명 미리 실행할 수 있을 것이다. 또, 
싱글 스레드 프로그램이라도 분명 동시에 처리할 수 있는 명령어가 있다. 이것을 명령어 
수준 병렬성(Instruction Level Parallelism, ILP)이라 부른다. 비순차 프로세서는 하드웨어가 
직접 실시간으로 ILP를 찾아 명령어 처리율을 극적으로 높인다. 보통 비순차 프로세서는 
수퍼스케일러 프로세서 형태로 작성된다. 그래야 동시에 두 개 이상의 병렬로 실행가능한 
명령어를 효과적으로 처리할 수 있기 때문이다. 이 명령어 수준 병렬성은 코드 상에 적혀진 
순서가 아닌 데이터 혹은 제어의 흐름으로 제약된다. 이를 의존성이라 부르며 대표적으로 
데이터 의존성, 컨트롤 의존성, 메모리 의존성이 있다. 요약하면 비순차 프로세서는 데이터 
흐름을 찾아 처리하는 프로세서로 볼 수 있다. 그러나 하드웨어의 제약으로 ILP를 찾을 수 
있는 범위가 제약적이다. 이 범위를 보통 명령어 윈도(Instruction Window)라 부르기도 한다. 
현대 프로세서는 약 100여개 이상의 명령어 속에서 ILP를 찾아 비순차 실행을 한다.

순차적 처리 프로세서
옛 프로세서에서는 다음과 같은 단계로 명령어를 실행하였다.

명령어를 읽어들인다.
입력 연산(operand)이 준비되어 있으면(이를테면 메모리에서 레지스터로 로드함) 명령어는  
적절한 실행 장치(functional unit)에 할당할 수 있다. 하나 이상의 연산이 현재의 클럭 
사이클 동안에 사용할 수 없다면 이 연산들을 사용할 수 있을 때까지 프로세서는 대기한다.
적절한 실행 장치가 명령어를 실행한다.
실행 장치는 실행 결과들을 레지스터 파일에 기록한다.
비순차적 처리 프로세서
새로운 패러다임은 명령어와 실행 결과를 일시적으로 모아 두는 장소를 만들어 명령어 
실행 과정을 다음과 같이 나눈다.:

명령어를 읽어들인다.
명령어 대기열(Reservation Station)에 명령어를 배치한다. 또, 리오더 버퍼(Reorder buffer)에도 
할당한다.
대기열에 있는 명령어들은 자신의 피연산자(operand)가 완료가 되는지 계속 명령어 완료 결과를
 엿듣는다.
피연산자가 모두 완료되면 이 명령어는 비로소 실행이 될 수 있고, 연산 장치(execution unit)
에 필요한 장치를 요구한다.
필요한 장치를 받으면 대기열에서 빠지고 실행이 된다(리오더 버퍼에는 계속 남아있어야 한다).
실행을 마치면 이 결과를 대기열에서 기다리는 명령에들에게 뿌린다(broadcasting).
리오더 버퍼에 자신이 완료되었다고 표시한다. 만약 리오더 버퍼에서 자신이 가장 오래된 
명령어라면 비로소 자신의 연산 결과(레지스터 혹은 메모리 결과)를 반영(commit)한다.
비순차 프로세서에서 유의해야할 점은 명령어 인출 단계와 맨 마지막 명령어 완료 단계는 
반드시 순차적으로 이루어진다는 점이다. 이것은 프로그래머와의 약속이다. 명령어가 
뒤죽박죽 완료된다면 프로그래머가 작업하기에 매우 어려울 것이다. 명령어 완료를 순차적으로 
하기 위해 필요한 장치가 리오더 버퍼이다.

이 밖에도 비순차 프로세서는 보통 순차 프로세서에서 겪지 않는 WAR/WAW 위험이 발생한다. 
이 문제를 해결하기 위해 레지스터 리네이밍(register renaming)이라는 기법을 이용한다.
*/
