/*
3-2. Control Hazard

파이프라인 방식에서는 앞선 명령어의 Fetch 단계 실행이 끝나면 
바로 다음 명령어의 실행을 시작해야 한다. 하지만 명령어를 Fetch 
단계까지만 실행하고서는 다음에 실행할 명령어가 무엇인지 바로 
결정하지 못하는 경우가 있다. 이에 대한 해결 방법으로는 크게 두 가지가 
있다. 첫째, 다음에 실행할 명령어의 주소를 예측(Predict)하여 
그 명령어를 우선 실행하고, 만약 나중에 그것이 잘못된 예측이었다는 
답을 얻게 되면 잘못 실행한 몇 개의 명령어들을 취소시키는 방법이다. 
둘째, 다음에 실행할 명령어의 주소를 정확하게 알아낼 때까지는 버블을 
삽입하면서 기다리는 방법이다.

우리가 구현할 Y86-64 파이프라인에서 다음에 실행할 명령어의 주소, 
즉 다음 PC 값을 결정하는 방식은 다음과 같다. 우선 PC 값을 바꾸지 않는
명령어들은 바로 다음 위치(valP)의 명령어를 실행하면 되고, 
무조건 분기와 call 명령어도 단순히 다음 PC 값을 valC로 설정하면 된다.
문제는 Fetch 단계에서 다음에 실행할 명령어의 주소를 정확히 알 수 
없는 경우이다. 바로 조건 분기 명령어와 ret 명령어이다.


조건 분기 명령어의 경우, 다음 PC의 값을 valC로 예상한다
(= 일단은 점프한다). 이 경우 만약 실제로 조건이 만족된 것이 맞다면 
문제없이 동작할 것이고, 조건이 만족되지 않았다면 틀린 동작이 된다. 
조건 만족 여부는 조건 분기 명령어가 Execute 단계에 돌입했을 때 
알 수 있는데, 직전 명령어의 실행 결과로 세팅된 컨디션 코드
레지스터의 값을 바탕으로 조건 만족 여부를 그때 계산할 수 있기 
때문이다. 또한, 조건 분기 명령어는 조건이 만족되지 않을 경우에
대비하여 조건 분기 명령어 바로 다음 위치 명령어의 주소에 해당하는
valP의 값(Fetch 단계에 계산됨)을 계속 위로 들고 올라간다. 
따라서 Memory 단계에 돌입하여 M_Cnd의 값을 통해 조건이 만족되지 
않았음을 파악하게 되면, M_valA로 전달받은 값을 바탕으로 다시 
올바른 명령어를 실행하게 된다. 그리고 이 순간에 Decode와 
Execute 단계에 위치하는 2개의 명령어는 잘못 실행된 명령어이므로
적절한 과정을 거쳐 이 둘을 취소시켜야 할 것이다

ret 명령어의 경우, 예측이라는 것을 할 수 없으므로 복귀 주소를 
알아낼 때까지 버블을 삽입하며 기다린다. 복귀 주소는 reqt 명령어가
Memory 단계에 돌입했을 때 알 수 있는데, 그때 메모리에서 복귀 
주소를 팝 할 수 있기 때문이다. 따라서 최소한 세 사이클은 버블을
끼워 넣으면서 기다려야 하고, Write Back 단계에 돌입하여 W_valM의
값을 통해 복귀 주소를 알아내면 그 주소에 해당하는 명령어를 Fetch
단계에서 실행하게 된다. 그리고 이 순간에 Decode, Execute,
Memory 단계에 위치하는 3개의 명령어는 잘못 실행된 명령어이므로
적절한 과정을 거쳐 이 셋을 취소시켜야 할 것이다
*/
